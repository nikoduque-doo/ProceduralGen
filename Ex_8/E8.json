{"camera":{"position":[6.407590276147093,1.0572810326102664,-0.16379709927789543],"target":[-0.13561697437243886,1.120270127102894,-1.136361377443249],"nearClipping":0.1,"farClipping":1000,"projection":"Perspective","perspectiveFov":45,"orthographicFov":30},"model":{"mesh":"quad","position":[0,-8,0],"rotationAxis":[1,0,0],"rotationAngle":-90,"scale":[0,0,0],"depthTest":"LESS","faceCulling":"","frontFace":"CCW","blendEnable":true,"blendOperation":"FUNC_ADD","srcColorBlendFactor":"SRC_ALPHA","dstColorBlendFactor":"ONE_MINUS_SRC_ALPHA","srcAlphaBlendFactor":"SRC_ALPHA","dstAlphaBlendFactor":"ONE_MINUS_SRC_ALPHA","textureFiltering":"LINEAR_MIPMAP_LINEAR","maxAnisotropy":"1"},"passes":{"Model":{},"Quad":{"R2T":{"shaders":{"vertex":{"source":"#version 300 es\n\n// Vertex coordinates in object space for the render quad\nin vec3 vertexPosition;\n// Texture coordinate for this vertex and the render quad\nin vec2 vertexTextureCoordinates;\n\n// Texture coordinate needs to be passed on to the R2T fragment shader\nout vec2 fragmentTextureCoordinates;\n\n// Main program for each vertex of the render quad\nvoid main() {\n  gl_Position = vec4(vertexPosition, 1.0);\n  fragmentTextureCoordinates = vertexTextureCoordinates;\n}"},"fragment":{"source":"#version 300 es\n\nprecision highp float;\n\n\n// Texture coordinates coming from the vertex shader, interpolated through the rasterizer\nin vec2 fragmentTextureCoordinates;\nout vec4 fragColor;\n\nuniform vec3 sunColor; // e.g. (1.64, 1.27, 0.99)\nuniform vec3 sunDirection; // e.g. (1,0.75,1)\nuniform vec3 skyColorLow; // e.g. (0.36, 0.45, 0.57)\nuniform vec3 skyColorHigh; // e.g. (0.14, 0.21, 0.49)\nuniform vec3 voidColor; // e.g. (0.025, 0.05, 0.075)\n\nuniform vec3 camPos; // Camera Position\nuniform mat4 ndcToView; // inverseProjectionMatrix\nuniform mat4 viewToWorld; // inverseViewMatrix\n\nuniform float imageWidth; // Canvas width in pixel\nuniform float imageHeight; // Canvas height in pixel\n\nuniform vec3 planePoint;\nuniform vec3 planeNormal;\n\nstruct Sphere{\n    vec3 center;\n    float radius;\n    vec3 color;\n};\n\nconst Sphere spheres[] = Sphere[](\n    Sphere(vec3(-2.0,1.5, -3.5),1.5,vec3(0.8,0.8,0.8)),\n    Sphere(vec3(-0.5,0.0, -2.0),0.6,vec3(0.3,0.8,0.3)),\n    Sphere(vec3( 1.0,0.7, -2.2),0.8,vec3(0.3,0.8,0.8)),\n    Sphere(vec3( 0.7, -0.3, -1.2),0.2,vec3(0.8,0.8,0.3)),\n    Sphere(vec3(-0.7, -0.3, -1.2),0.2,vec3(0.8,0.3,0.3)),\n    Sphere(vec3( 0.2, -0.2, -1.2),0.3,vec3(0.8,0.3,0.8))\n);\n\nvec3 backgroundColor(vec3 rd){ // Fine tuned by pure arbitrariness\n    if(rd.y < 0.0) {return voidColor;}\n    const float skyGradient = 1./4.;\n    vec3 skyColor = mix(skyColorLow, skyColorHigh, pow(rd.y, skyGradient));\n    const float sunGradient = 2400.;\n    float sunAmount = pow(max(dot(rd,normalize(sunDirection)), 0.),sunGradient);\n    return mix(skyColor, sunColor, sunAmount);\n}\n\n\n// HDR to LDR conversion using an approximated ACES curve and gamma corrected using the fast gamma==(1/2.2) approximation for linear to sRGB\nvec3 tonemapAndGammaCorrect(const vec3 x){\n    return pow(clamp((x*(2.51*x+0.03)/(x*(2.43*x+0.59)+0.14)),0.0,1.0),vec3(1.0/2.2));\n}\n\nfloat sphereIntersect(vec3 ro, vec3 rd, Sphere s){\n    ro -= s.center;\n    float b = dot(ro,rd);\n    float c = dot(ro,ro) - s.radius*s.radius;\n    float d = b*b - c;\n    if(d < 0.0) return -1.; // No intersection\n    d = sqrt(d);\n    float t1 = -b - d;\n    float t2 = -b + d;\n\n    if(t1 < 0.0) return t2; // Potentially inside\n    return t1;\n}\n\nfloat closestSphereIntersect(vec3 ro, vec3 rd, out int sphereIndex){\n    /* Infinity in IEEE 754 floats. If this doesn't work use a very large number (e.g.\n    1e42) instead.*/\n    float closestHit = 1e42;\n    /* Is negative in case no sphere is hit. Could also use a check in the end whether\n    closest hit is too far away to determine whether anything was hit at all.*/\n    float bestT = -1.0;\n    for(int i = 0; i < spheres.length(); i++){\n        float t = sphereIntersect(ro,rd,spheres[i]);\n        if(t < 0.0 || t > closestHit) {\n            continue;\n        }\n        closestHit = bestT = t;\n        sphereIndex = i;\n    }\n    return bestT;\n}\n\nfloat planeIntersect(vec3 ro, vec3 rd, vec3 n, vec3 p){\n    return dot(p-ro,n)/dot(rd,n);\n}\n\nvec3 checkerboard(vec3 point, float tileSize){\n    vec2 p = point.xz / tileSize;\n    vec2 t = floor(p+0.5);\n    if(t.x == 0.0 || t.y == 0.0){ // middle line for better orientation\n        return vec3(1.0,0.8,0.4);\n    }\n    return mix(vec3(1.),vec3(.1),mod(t.x+t.y,2.));\n}\n\nfloat shadowRay(vec3 ro, vec3 rd){\n    int ignore;\n    float tSphere = closestSphereIntersect(ro, rd, ignore);\n    return 1.-step(0.0,tSphere); // 1 if tSphere < 0 else 0\n}\n\nvec3 lightAtPoint(vec3 point, vec3 N){\n    vec3 L = normalize(sunDirection);\n    float NdL = max(dot(N,L),0.0);\n    float NdSky = clamp(0.5*N.y+0.5, 0.0, 1.0 );\n    float shadow = shadowRay(point + 1e-3*N, L);\n    \n    return sunColor * NdL * shadow + skyColorHigh * NdSky;\n}\n\nstruct rayIntersectionPoint {\n    float t;\n    vec3 normal;\n    vec3 color;\n};\n\nrayIntersectionPoint sceneIntersect(vec3 rayOrigin, vec3 rayDirection){\n    rayIntersectionPoint point;\n    int sphereIndex;\n\n    float tS = closestSphereIntersect(rayOrigin,rayDirection,sphereIndex);\n    float tP = planeIntersect(rayOrigin, rayDirection, normalize(planeNormal) ,planePoint);\n\n    if(tS <= 0.0 && tP <= 0.0){\n        point.t = min(tS,tP);\n        point.color = backgroundColor(rayDirection);\n        return point;\n    }\n    \n    if ((tS > tP && tP > 0.0) || (tS <= 0.0)){\n        point.t = tP;\n        point.normal = normalize(planeNormal);\n        vec3 hitPoint = rayOrigin + point.t*rayDirection;\n        point.color = checkerboard(hitPoint,1.0);\n    } else if ((tS < tP && tS > 0.0) || (tP <= 0.0)) {\n        point.t = tS;\n        vec3 hitPoint = rayOrigin + point.t*rayDirection;\n        point.normal = normalize(hitPoint-spheres[sphereIndex].center);\n        point.color = spheres[sphereIndex].color;\n    }\n\n    return point;\n}\n\nvoid main() {\n    vec3 rayOrigin = camPos;\n    vec2 pixelNdc = 2. * fragmentTextureCoordinates - 1.;\n    vec3 pixelViewSpace = (ndcToView * vec4(pixelNdc,1.,1.)).xyz;\n    vec3 rayDirection = normalize(mat3(viewToWorld) * pixelViewSpace);\n\n    vec3 color = vec3(0.0);\n    rayIntersectionPoint point = sceneIntersect(rayOrigin, rayDirection);\n\n    int sphereIndex;\n    if(point.t > 0.0){\n        vec3 hitPoint = rayOrigin + point.t*rayDirection;\n        vec3 light = lightAtPoint(hitPoint,point.normal);\n        color += point.color * light;\n    } else {\n        color = point.color;\n    }\n    fragColor = vec4(tonemapAndGammaCorrect(color), 1.);\n}"}},"uniforms":{"value":{"sunColor":{"value":[1.64,1.27,0.99]},"sunDirection":{"value":[1,0.75,1]},"skyColorLow":{"value":[0.36,0.45,0.57]},"skyColorHigh":{"value":[0.14,0.21,0.49]},"voidColor":{"value":[0.025,0.05,0.075]},"camPos":{"attachment":"Camera Position"},"ndcToView":{"attachment":"Inverse Projection Matrix"},"viewToWorld":{"attachment":"Inverse View Matrix"},"imageWidth":{"attachment":"Canvas Width"},"imageHeight":{"attachment":"Canvas Height"},"planePoint":{"value":[0,-2,0]},"planeNormal":{"value":[0,1,0]}}}}}},"output":{"image":"Quad/R2T Pass color"}}