{"camera":{"position":[10.220055188352193,6.0434416463964835,38.197215670957796],"target":[0,0,0],"nearClipping":0.1,"farClipping":1000,"projection":"Perspective","perspectiveFov":45,"orthographicFov":30},"model":{"mesh":"teapot","position":[0,-8,0],"rotationAxis":[1,0,0],"rotationAngle":-90,"scale":[1,1,1],"depthTest":"LESS","faceCulling":"","frontFace":"CCW","blendEnable":true,"blendOperation":"FUNC_ADD","srcColorBlendFactor":"SRC_ALPHA","dstColorBlendFactor":"ONE_MINUS_SRC_ALPHA","srcAlphaBlendFactor":"SRC_ALPHA","dstAlphaBlendFactor":"ONE_MINUS_SRC_ALPHA","textureFiltering":"LINEAR_MIPMAP_LINEAR","maxAnisotropy":"1"},"passes":{"Model":{"base":{"shaders":{"vertex":{"source":"#version 300 es\n\n// Vertex position in object space coordinates\nin vec3 vertexPosition;\n// Surface normal at the vertex in object space coordinates\nin vec3 vertexNormal;\n// Texture coordinates at that vertex\nin vec2 vertexTextureCoordinates;\n\nout vec3 fragPos;\nout vec3 fragN;\nout vec3 camPos;\n\n// Model matrix\nuniform mat4 mMatrix;\n// View matrix\nuniform mat4 vMatrix;\n// Projection matrix\nuniform mat4 pMatrix;\n\n// Main program for each vertex\nvoid main() {\n  vec4 vertexCamSpace = vMatrix * mMatrix * vec4(vertexPosition, 1.0);\n  gl_Position = pMatrix * vertexCamSpace;\n\n  fragPos = (mMatrix * vec4(vertexPosition, 1.0)).xyz;\n  fragN = (transpose(inverse(mMatrix)) * vec4(vertexNormal, 0.0)).xyz;\n  camPos = (inverse(vMatrix) * vec4(0.0, 0.0, 0.0, 1.0)).xyz;\n}"},"fragment":{"source":"#version 300 es\n\n// For better performance less precision\nprecision highp float;\n\nin vec3 fragPos;\nin vec3 fragN;\nin vec3 camPos;\n\nuniform vec3 lightDirection;\nuniform vec3 lightColor;\nuniform float kA; // 0.5\nuniform float kD; // 1.0\nuniform float kS; // 0.5\nuniform float s; // 20\nuniform float Ia; // 0.5\n\nout vec4 fragColor;\n\n// Main program for each fragment = pixel candidate\nvoid main() {\n  vec3 baseColor = vec3(0.0, 1.0, 0.0);\n\n  vec3 l = normalize(lightDirection);\n  vec3 n = normalize(fragN);\n  vec3 v = normalize(camPos - fragPos);\n\n  vec3 h = normalize(v + l);\n\n  float Id = clamp(dot(n, l), 0.0, 1.0);\n  float Is = pow(clamp(dot(n, h), 0.0, 1.0), s);\n  vec3 color = ((kA * Ia + kD * Id) * baseColor + (kS * Is) * vec3(1.0)) * lightColor;\n  fragColor = vec4(color, 1.0);\n}"}},"uniforms":{"value":{"mMatrix":{"attachment":"Model Matrix"},"vMatrix":{"attachment":"View Matrix"},"pMatrix":{"attachment":"Projection Matrix"},"lightDirection":{"value":[0,0,1]},"lightColor":{"value":[1,1,1]},"kA":{"value":[0.5]},"kD":{"value":[1]},"kS":{"value":[0.5]},"s":{"value":[80]},"Ia":{"value":[0.5]}}}}},"Quad":{"R2T":{"shaders":{"vertex":{"source":"#version 300 es\n\n// Vertex coordinates in object space for the render quad\nin vec3 vertexPosition;\n// Texture coordinate for this vertex and the render quad\nin vec2 vertexTextureCoordinates;\n\n// Texture coordinate needs to be passed on to the R2T fragment shader\nout vec2 fragmentTextureCoordinates;\n\n// Main program for each vertex of the render quad\nvoid main() {\n  gl_Position = vec4(vertexPosition, 1.0);\n  fragmentTextureCoordinates = vertexTextureCoordinates;\n}"},"fragment":{"source":"#version 300 es\n\nprecision highp float;\n\n// A texture sampling unit, which is bound to the render quad texture buffer\nuniform sampler2D textureRendered;\n\nuniform bool blur;\nuniform bool sRGB;\n\n// Texture coordinates coming from the vertex shader, interpolated through the rasterizer\nin vec2 fragmentTextureCoordinates;\nout vec4 fragColor;\n\nvec3 linearToSRGB (vec3 linearRGB){\n    return mix(1.055 * pow(linearRGB, vec3(1.0 / 2.4)) - 0.055,\n    linearRGB * 12.92, lessThanEqual(linearRGB, vec3(0.0031308)));\n}\n\n// Main program for each fragment of the render quad\nvoid main() {\n  vec4 linearRGB;\n\n  if(blur){\n    const int n = 12;\n    float s[n];\n    s[0] = -0.10568; s[1] = -0.07568; s[2] = -0.042158;\n    s[3] = -0.02458; s[4] = -0.01987456; s[5] = -0.0112458;\n    s[6] = 0.0112458; s[7] = 0.01987456; s[8] = 0.02458;\n    s[9] = 0.042158; s[10] = 0.07568; s[11] = 0.10568;\n\n    vec3 blurColor = vec3(0.0,0.0,0.0);\n    vec2 vectorToCenter = fragmentTextureCoordinates - vec2(0.5,0.5);\n    float d_max = float(textureSize(textureRendered, 0).x)/750.0;\n\n    for(int i = 0; i < n; i++){\n        blurColor += texture(textureRendered, fragmentTextureCoordinates + \n                            vectorToCenter * (s[i] * d_max)).xyz;\n    }\n\n    blurColor /= 12.0;\n\n    linearRGB = vec4(blurColor, 1.0);\n  } else {\n    linearRGB = texture(textureRendered, fragmentTextureCoordinates);\n  }\n\n  if(sRGB){\n    fragColor = vec4(linearToSRGB(linearRGB.rgb), linearRGB.a);\n  } else {\n    fragColor = linearRGB;\n  }\n  \n}"}},"uniforms":{"value":{"textureRendered":{"attachment":"Model/base Pass color"},"blur":{"value":[false]},"sRGB":{"value":[true]}}}}}},"output":{"image":"Quad/R2T Pass color"}}